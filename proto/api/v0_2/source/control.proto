syntax = "proto3";

// Author: kry127
// Purpose: this file defines control messages that solve two problems:
//   1. At Least Once guarantee for data ingestion
//   2. Parallelization of snapshot process

package yandexcloud.datatransfer.dtextension.v0_2.source;

import "api/v0_2/data.proto";

// Control item requests for snapshot process
message ReadControlItemReq {
    oneof control_item_req {
        InitConnectionReq init_connection_req = 1;
        DataItemReq data_item_req = 2;
        CursorReq cursor_req = 3;
        BeginSnapshotReq begin_snapshot_req = 4;
        DoneSnapshotReq done_snapshot_req = 5;
    }
}

// Control item response for snapshot process
message ReadControlItemRsp {
    oneof control_item_rsp {
        InitConnectionRsp init_connection_rsp = 1;
        DataItemRsp data_item_rsp = 2;
        CursorRsp cursor_rsp = 3;
        BeginSnapshotRsp begin_snapshot_rsp = 4;
        DoneSnapshotRsp done_snapshot_rsp = 5;
    }
}


// InitConnectionReq -- is the first connection message that is needed to initiate
// connection with source database with settings used by user
// client_id -- when non empty, used to identify client that may perform multiple operations on service.
// You may ignore this field if you make implementation for single client
message InitConnectionReq {
    string json_settings = 1;
    string client_id = 2;
}
// client_id -- generated client id, if it was empty in `InitConnectionReq`
// You may ignore this field if you make implementation for single client
message InitConnectionRsp {
    string client_id = 2;
}

// This message is sent in order to acquire snapshot cursor
// that will iterate through snapshotting values
// note, that cursor value will be stored in general response
message CursorReq {
    // This parameter designates preferred column for cursor
    string preferred_column = 1;
}
message CursorRsp {}

// This message designates snapshot beginning
// When this message comes, source connector should designate bounds
// of transferring lines, or take read snapshot lock for consistency
message BeginSnapshotReq {}
message BeginSnapshotRsp {
    // this optional parameter is used to save snapshot state binary representation
    bytes snapshot_state = 2;
}

// This message designates a finish of snapshot
// Resources that might have been allocated during BeginSnapshotReq may be freed now
message DoneSnapshotReq {
    bytes snapshot_state = 1;
}
message DoneSnapshotRsp {}


// This message requests data change item
message DataItemReq {}
message DataItemRsp {
    ChangeItem change_item = 1;
}

message StreamControlItemReq {
    oneof control_item_req {
        InitConnectionReq init_connection_req = 1;
        FixLsnReq fix_lsn_req = 2;
        CheckLsnReq check_lsn_req = 3;
        DataItemReq data_item_req = 4;
        RewindLsnReq rewind_lsn_req = 5;
    }
}

message StreamControlItemRsp {
    oneof control_item_rsp {
        InitConnectionRsp init_connection_rsp = 1;
        FixLsnRsp fix_lsn_rsp = 2;
        CheckLsnRsp check_lsn_rsp = 3;
        DataItemRsp data_item_rsp = 4;
        RewindLsnReq rewind_lsn_req = 5;

        LostRequestedLsnRsp lost_requested_lsn_rsp = 6;

        StartTransactionRsp start_transaction_rsp = 7;
        StopTransactionRsp stop_transaction_rsp = 8;
    }
}

// This message requests to fix current LSN for specified replication source
// The returned message is user LSN that designate where stream will be read from
// After this message, each further read of item moves LSN forward
message FixLsnReq {
    StreamSource stream_source = 1;

    message StreamSource {
        oneof source {
            Table table = 1;
            Namespace namespace = 2;
            Cluster cluster = 3;
        }

        // this means it contains all namespaces -- all possible messages are replicated
        message Cluster {}
    }
}
message FixLsnRsp {
    // this is an optional field if source have to store some additional info for fixing LSN position
    bytes replication_state = 3;
}

// This message queries is LSN is still presented in the stream
// If LSN lost, LostRequestedLsnRsp should be returned
message CheckLsnReq {
    ColumnValue lsn = 1;
}
message CheckLsnRsp {}

// This message rewinds LSN (e.g. makes it no longer fixed to a certain point)
message RewindLsnReq {
    // the replication state is sequece of bytes returned by `FixLsnReq` and it is needed to free resources allocated
    // to lock replication position
    bytes replication_state = 1;
}
message RewindLsnRsp {}

// This message notifies user that requested next item that his LSN
// has been lost from the log.
message LostRequestedLsnRsp {}


// This message can be returned on DataItemReq and identifies starting the transaction
message StartTransactionRsp {}
// This message can be returned on DataItemReq and identifies stopping the transaction
// The messages send by source between StartTransactionRsp and StopTransactionRsp are
// identified as single transaction
message StopTransactionRsp {}
