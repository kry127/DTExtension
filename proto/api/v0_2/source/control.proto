syntax = "proto3";

// Author: kry127
// Purpose: this file defines control messages that solve two problems:
//   1. At Least Once guarantee for data ingestion
//   2. Parallelization of snapshot process

package yandexcloud.datatransfer.dtextension.v0_2.source;

import "api/v0_2/common.proto";
import "api/v0_2/data.proto";

// There are two types of control items:
//  1. ReadControlItemReq/ReadControlItemRsp -- control items for Read protocol
//  2. StreamControlItemReq/StreamControlItemRsp -- control items for Stream protocol
// Most commonly, there is such system of interaction: client sends "<Type>Req" message,
// and server responds with single "<Type>Rsp" message.
// The only exception is ChangeStreamReq -- this single request produces multibple ChangeStreamRsp.

// Control item requests for snapshot process
message ReadCtlReq {
    oneof ctl_req {
        InitReq init_req = 1;
        ReadChangeReq read_change_req = 2;
        CursorReq cursor_req = 3;
        BeginSnapshotReq begin_snapshot_req = 4;
        DoneSnapshotReq done_snapshot_req = 5;
    }
}

// Control item response for snapshot process
message ReadCtlRsp {
    oneof ctl_rsp {
        InitRsp init_rsp = 1;
        ReadChangeRsp read_change_rsp = 2;
        CursorRsp cursor_rsp = 3;
        BeginSnapshotRsp begin_snapshot_rsp = 4;
        DoneSnapshotRsp done_snapshot_rsp = 5;
    }
}

// This message requests stream of data change item specified by cursor
message ReadChangeReq {
    Cursor cursor = 1;
}
// After receiving ReadChangeReq, server should produce series of ReadChangeRsp containing data in change_item
// field. When sequence of ReadChangeRsp ends from server side, server should send last ReadChangeRsp message
// with "end_of_read" message. The client should wait until this message until further actions.
message ReadChangeRsp {
    oneof change_stream_item {
        ChangeItem change_item = 1;
        EndOfRead end_of_read = 2;
    }

    // End of stream message should advance cursor in order to retrieve new values,
    // otherwise source may stuck sending the same values over and over again
    message EndOfRead {
        Cursor cursor = 1;
    }
}


// InitConnectionReq -- is the first connection message that is needed to initiate
// connection with source database with settings used by user
// client_id -- when non empty, used to identify client that may perform multiple operations on service.
// You may ignore this field if you make implementation for single client
message InitReq {
    string json_settings = 1;
    string client_id = 2;
}
// client_id -- generated client id, if it was empty in `InitConnectionReq`
// You may ignore this field if you make implementation for single client
message InitRsp {
    string client_id = 2;
}

// This message is sent in order to acquire snapshot cursor
// that will iterate through snapshotting values
// note, that cursor value will be stored in general response
message CursorReq {
    // This parameter designates preferred column for cursor
    string preferred_column = 1;
}
message CursorRsp {
    Cursor cursor = 1;
}

// This message designates snapshot beginning
// When this message comes, source connector should designate bounds
// of transferring lines, or take read snapshot lock for consistency
message BeginSnapshotReq {}
message BeginSnapshotRsp {
    // this optional parameter is used to save snapshot state binary representation
    bytes snapshot_state = 2;
}

// This message designates a finish of snapshot
// Resources that might have been allocated during BeginSnapshotReq may be freed now
message DoneSnapshotReq {
    bytes snapshot_state = 1;
}
message DoneSnapshotRsp {}



message StreamCtlReq {
    oneof ctl_req {
        InitReq init_req = 1;
        FixLsnReq fix_lsn_req = 2;
        CheckLsnReq check_lsn_req = 3;
        StreamChangeReq stream_change_req = 4;
        RewindLsnReq rewind_lsn_req = 5;
    }
}

message StreamCtlRsp {
    oneof ctl_rsp {
        InitRsp init_rsp = 1;
        FixLsnRsp fix_lsn_rsp = 2;
        CheckLsnRsp check_lsn_rsp = 3;
        StreamChangeRsp stream_change_rsp = 4;
        RewindLsnReq rewind_lsn_req = 5;

        LostLsnRsp lost_lsn_rsp = 6;
    }
}

// This message requests stream of data change item
message StreamChangeReq {}
// After receiving StreamChangeReq, server should produce series of StreamChangeRsp containing data in change_item
// field. When sequence of ChangeStreamRsp ends from server side, server should send last ChangeStreamRsp message
// with "end_of_stream" message. Change items between StartTransaction and StopTransaction considered
// within single transaction. The client should wait until message EndOfStream until further actions.
message StreamChangeRsp {
    oneof change_stream_item {
        ChangeItem change_item = 1;
        StartTransaction start_transaction = 2;
        StopTransaction stop_transaction = 3;
        EndOfStream end_of_stream = 4;
    }

    // This message identifies starting of the transaction, useful in Stream sources
    message StartTransaction {}
    // This message identifies stopping the transaction
    // The messages of variant type change_item in ChangeStreamRsp between StartTransactionRsp and StopTransactionRsp
    // are identified as single transaction
    message StopTransaction {}
    // End of stream message should advance cursor in order to retrieve new values,
    // otherwise source may stuck sending the same values over and over again
    message EndOfStream {}
}

// This message requests to fix current LSN for specified replication source
// The returned message is user LSN that designate where stream will be read from
// After this message, each further read of item moves LSN forward
message FixLsnReq {
    StreamSource stream_source = 1;

    message StreamSource {
        oneof source {
            Table table = 1;
            Namespace namespace = 2;
            Cluster cluster = 3;
        }

        // this means it contains all namespaces -- all possible messages are replicated
        message Cluster {}
    }
}
message FixLsnRsp {
    // this is an optional field if source have to store some additional info for fixing LSN position
    bytes replication_state = 3;
}

// This message queries is LSN is still presented in the stream
// If LSN lost, LostRequestedLsnRsp should be returned
message CheckLsnReq {
    ColumnValue lsn = 1;
}
message CheckLsnRsp {}

// This message rewinds LSN (e.g. makes it no longer fixed to a certain point)
message RewindLsnReq {
    // the replication state is sequece of bytes returned by `FixLsnReq` and it is needed to free resources allocated
    // to lock replication position
    bytes replication_state = 1;
}
message RewindLsnRsp {}

// This message notifies user that requested next item that his LSN
// has been lost from the log.
message LostLsnRsp {}
